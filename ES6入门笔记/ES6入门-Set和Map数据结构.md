- Set

  类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构

  ```
  const s = new Set();
  
  [2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
  
  for (let i of s) {
    console.log(i);
  }
  // 2 3 5 4
  ```

  - 可用于去除数组重复成员

  - 属性和方法

    - `Set.prototype.constructor`：构造函数，默认就是`Set`函数。
    - `Set.prototype.size`：返回`Set`实例的成员总数。

    ------



```
- `add(value)`：添加某个值，返回 Set 结构本身。
- `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。
- `has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。
- `clear()`：清除所有成员，没有返回值。
```

- `Array.from`方法可以将 Set 结构转为数组。

- 遍历操作：

  - `keys()`：返回键名的遍历器
  - `values()`：返回键值的遍历器
  - `entries()`：返回键值对的遍历器
  - `forEach()`：使用回调函数遍历每个成员

  由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以`keys`方法和`values`方法的行为完全一致。

- 在遍历过程中，同步改变set解构方法

  ```
  // 方法一
  let set = new Set([1, 2, 3]);
  set = new Set([...set].map(val => val * 2));
  // set的值是2, 4, 6
  
  // 方法二
  let set = new Set([1, 2, 3]);
  set = new Set(Array.from(set, val => val * 2));
  // set的值是2, 4, 6
  ```

- WeakSet

  - 与Set区别：

    - 成员只能是对象，而不能是其他类型的值。

  - WeakSet 是一个构造函数，可以使用`new`命令，创建 WeakSet 数据结构。

    作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。

    ```
    const a = [[1, 2], [3, 4]];
    const ws = new WeakSet(a);
    // WeakSet {[1, 2], [3, 4]}
    ```

    注意，是`a`数组的成员成为 WeakSet 的成员，而不是`a`数组本身。这意味着，数组的成员只能是对象。

- Map

  ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。

  同样的值的两个实例，在 Map 结构中被视为两个键。

  ```
  const map = new Map();
  
  const k1 = ['a'];
  const k2 = ['a'];
  
  map
  .set(k1, 111)
  .set(k2, 222);
  
  map.get(k1) // 111
  map.get(k2) // 222   变量k1和k2的值是一样的，但是它们在 Map 结构中被视为两个键。
  ```

  Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题

  如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如`0`和`-0`就是一个键，布尔值`true`和字符串`true`则是两个不同的键。另外，`undefined`和`null`也是两个不同的键。虽然`NaN`不严格相等于自身，但 Map 将其视为同一个键。

  - 属性和方法：
    - `size`属性返回 Map 结构的成员总数。
    - `set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。
    - `get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。
    - `has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。
    - `delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。
    - `clear`方法清除所有成员，没有返回值。
  - 遍历方法：
    - `keys()`：返回键名的遍历器。
    - `values()`：返回键值的遍历器。
    - `entries()`：返回所有成员的遍历器。
    - `forEach()`：遍历 Map 的所有成员。
  - Map 结构转为数组结构，比较快速的方法是使用扩展运算符（`...`）。
  - 结合数组的`map`方法、`filter`方法，可以实现 Map 的遍历和过滤（Map 本身没有`map`和`filter`方法）。

- WeakMap

  区别：只接受对象作为键名，键名所指向的对象，不计入垃圾回收机制。

  `WeakMap`的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。

  ```
  const e1 = document.getElementById('foo');
  const e2 = document.getElementById('bar');
  const arr = [
    [e1, 'foo 元素'],
    [e2, 'bar 元素'],
  ];
  ```

  一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放`e1`和`e2`占用的内存。

  一旦忘了写，就会造成内存泄露。

  WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。
